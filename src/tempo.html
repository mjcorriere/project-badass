<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>

    <script src="underscore.js" type="text/javascript"></script>    
    <canvas id="render-window" width="600" height="300" style="border:1px dotted;float:left"></canvas>
    <script>

        window.requestAnimFrame = (function(callback) 
        {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame 
            || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();

        function sigh(rgb)
        {
            return 'rgb(' + rgb.join(',') + ')';
        }

        function drawParticle(particle, context)
        {
            context.beginPath();

            context.fillStyle=sigh(particle.color);
            context.arc(particle.position[0], particle.position[1], particle.radius, 2 * Math.PI, false);

            context.fill();
        }

        var
            potentials = {

                id : function(pos) { return pos; },
                spring : function(k, pos) { return { x : -k * pos.x, y : -k * pos.y } }
            },
            linear_force = function(f_x, f_y) { 
                return function(pos, dt) { [ pos.x + (f_x * dt), pos.y + (f_y * dt) ]; } 
            },
            harmonic_force = function(c1, c2, k, m) {
                return function (pos, dt) { return pos; }
            },
            particle_forces = [ 
                { force : linear_force(0.01, 0.003)   },
                { force : linear_force(0.005, -0.001) },
                { force : harmonic_force(0, 0, 0, 0)  }
            ],
            Particle = function(_mass, _position, _radius, _color, _velocity, _forces)
            {
                return {

                    mass : _mass ? _mass : 0.0,
                    position : _position ? _position : [0.0, 0.0],
                    velocity : _velocity ? _velocity : [0.0, 0.0],
                    forces : _forces ? _forces : [0.0, 0.0],
                    radius : _radius ? _radius : 5.0,
                    color : _color ? _color : [0.5 * 255, 0.5 * 255, 0.5 * 255]
                };
            },
            particles = [
                Particle(1.0, [100, 150], 5, [0.5 * 255, 0.5 * 255, 0.5 * 255], [0.5, 0.1]),
                Particle(1.0, [20, 50],   5, [0.0 * 255, 0.3 * 255, 0.5 * 255], [-0.3, 0.2]),
                Particle(1.0, [40, 80],   5, [0.5 * 255, 0.3 * 255, 0.0 * 255], [-0.1, -0.2])
            ];

        function clear_forces(particles)
        {
            _.each(particles, function(particle) {

                particle.forces = [0.0, 0.0];

            });
        }

        function sum(a, b)
        {
            return [a[0] + b[0], a[1] + b[1]];
        }

        function diff (a, b)
        {
            return [a[0] - b[0], a[1] - b[1]];
        }

        function dot(a, b)
        {
            return a[0] * b[0] + a[1] * b[1];
        }

        function length(a)
        {
            return Math.sqrt(dot(a, a));
        }

        function scale(a, f)
        {
            return [f * a[0], f * a[1]];
        }

        function normalized(a)
        {
            return scale(1.0 / length(a), a);
        }

        function reflect(v, n)
        {
            var
                b = diff(n, v),
                a = dot(n, v) * 2.0; 

            return scale(b, a);
        }

        function compute_forces(particles)
        {
            // For this simple system, aside from the initial impulses the only forces
            // are those arising from inelastic collisions
            for(var i = 0; i < particles.length; i++)
            {
                for(var j = 0; j < particles.length; j++)
                {
                    if (i == j) continue;

                    var
                        delta = diff(particles[i].position, particles[j].position),
                        dir = particles[i].velocity,
                        r = particles[j].radius;

                    var
                        discrim = Math.pow(dot(delta, dir), 2) - (dot(dir, dir) * (dot(delta, delta) - r * r));

                    if (discrim > 0)
                    {

                        var
                            dir_squared_length = dot(dir, dir); 
                            dir_dot_delta = dot(scale(dir, -1), delta),
                            abs_discrim_root = Math.sqrt(discrim);

                        var 
                            plus_t = (dir_dot_delta + abs_discrim_root) / dir_squared_length,
                            minus_t = (dir_dot_delta - abs_discrim_root) / dir_squared_length;

                        var
                            intersection_t = Math.min(plus_t, minus_t);

                        var
                            intersection_point = sum(particles[i].position, scale(normalized(dir), intersection_t));

                        var
                            n_i = normalized(diff(intersection_point, particles[i].position)),
                            n_j = normalized(diff(intersection_point, particles[j].position));

                        var
                            reflected_i = reflect(particles[i].velocity, n_j),
                            reflected_j = reflect(particles[j].velocity, n_i);

                        particles[i].velocity = reflected_i;
                        particles[j].velocity = reflected_j;
                    }
                }
            }
        }

        function warp(coord, bound)
        {
            if (coord < 0)
            {
                return bound;
            }
            else if (coord > bound)
            {
                return 0;
            }

            return coord;
        }

        function step(particles, dt)
        {
            // TODO: parameterize integrator
            //
            _.each(particles, function(particle)
            {
                // First apply the direct force
                particle.velocity[0] += (particle.forces[0] * dt);
                particle.velocity[1] += (particle.forces[1] * dt);

                particle.position[0] += particle.velocity[0] * dt;
                particle.position[1] += particle.velocity[1] * dt;

                // Turn our viewport into a torus!
                particle.position[0] = warp(particle.position[0], 600);
                particle.position[1] = warp(particle.position[1], 300);

                // Then the indirect
                //particle = force.potential(particle);
            });
        }

        function animate(particles, canvas, context, startTime) 
        {
            // TODO: use a fixed timestep
            //
            var time = (new Date()).getTime();
            var dt = time - startTime;

            // clear
            context.clearRect(0, 0, canvas.width, canvas.height);

            clear_forces(particles);
            compute_forces(particles);
            step(particles, dt);

            // draw it
            _.each(particles, function(particle) 
            {
                drawParticle(particle, context);
            });

            startTime = time;

            // request new frame
            requestAnimFrame(function() {
              animate(particles, canvas, context, startTime);
            });
        }

        var canvas = document.getElementById('render-window');
        var context = canvas.getContext('2d');

        // wait one second before starting animation
        setTimeout(function() 
        {
            var startTime = (new Date()).getTime();
            animate(particles, canvas, context, startTime);
        }, 1000);

    </script>
  </body>
</html>
