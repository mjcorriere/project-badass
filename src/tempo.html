<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>

    <script src="underscore.js" type="text/javascript"></script>    
    <canvas id="render-window" width="600" height="300" style="border:1px dotted;float:left"></canvas>
    <script>

        window.requestAnimFrame = (function(callback) 
        {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame 
            || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();

        function sigh(rgb)
        {
            ceiled = _.map(rgb, Math.ceil);
            return 'rgb(' + ceiled.join(',') + ')';
        }

        function drawParticle(particle, context)
        {
            context.beginPath();

            context.fillStyle=sigh(particle.color);
            context.arc(particle.position[0], particle.position[1], particle.radius, 2 * Math.PI, false);

            context.fill();
        }

        var
            potentials = {

                id : function(pos) { return pos; },
                spring : function(k, pos) { return { x : -k * pos.x, y : -k * pos.y } }
            },
            linear_force = function(f_x, f_y) { 
                return function(pos, dt) { [ pos.x + (f_x * dt), pos.y + (f_y * dt) ]; } 
            },
            harmonic_force = function(c1, c2, k, m) {
                return function (pos, dt) { return pos; }
            },
            particle_forces = [ 
                { force : linear_force(0.01, 0.003)   },
                { force : linear_force(0.005, -0.001) },
                { force : harmonic_force(0, 0, 0, 0)  }
            ],
            Particle = function(_mass, _position, _radius, _color, _velocity, _forces)
            {
                return {

                    mass : _mass ? _mass : 0.0,
                    position : _position ? _position : [0.0, 0.0],
                    velocity : _velocity ? _velocity : [0.0, 0.0],
                    forces : _forces ? _forces : [0.0, 0.0],
                    radius : _radius ? _radius : 5.0,
                    color : _color ? _color : [0.5 * 255, 0.5 * 255, 0.5 * 255]
                };
            },
            particles = [
                Particle(1.0, [100, 150], 5, [0.5 * 255, 0.5 * 255, 0.5 * 255], [0.5, 0.0]),
                Particle(1.0, [320, 150],   5, [0.0 * 255, 0.3 * 255, 0.5 * 255], [-0.5, 0.0]),
            /*
                Particle(1.0, [100, 150], 5, [0.5 * 255, 0.5 * 255, 0.5 * 255], [0.5, 0.1]),
                Particle(1.0, [20, 50],   5, [0.0 * 255, 0.3 * 255, 0.5 * 255], [-0.3, 0.2]),
                Particle(1.0, [40, 80],   5, [0.5 * 255, 0.3 * 255, 0.0 * 255], [-0.1, -0.2])
            */
            ];

        function clear_forces(particles)
        {
            _.each(particles, function(particle) {

                particle.forces = [0.0, 0.0];

            });
        }

        function sum(a, b)
        {
            return [a[0] + b[0], a[1] + b[1]];
        }

        function diff (a, b)
        {
            return [a[0] - b[0], a[1] - b[1]];
        }

        function dot(a, b)
        {
            return a[0] * b[0] + a[1] * b[1];
        }

        function length(a)
        {
            return Math.sqrt(dot(a, a));
        }

        function scale(a, f)
        {
            return [f * a[0], f * a[1]];
        }

        function normalized(a)
        {
            return scale(a, 1.0 / length(a));
        }

        function reflect(v, n)
        {
            var
                coeff = 2.0 * dot(n, v);

            return diff(v, scale(n, coeff));
        }

        function perp(v)
        {
            return [v[1], -v[0]];
        }

        function intersect_particles(one, two)
        {
            var
                delta = diff(one.position, two.position),
                dir = one.velocity,
                r = two.radius;

            var
                discrim = Math.pow(dot(delta, dir), 2) - (dot(dir, dir) * (dot(delta, delta) - r * r));

            if (discrim > 0)
            {

                var
                    dir_squared_length = dot(dir, dir); 
                    dir_dot_delta = dot(scale(dir, -1), delta),
                    abs_discrim_root = Math.sqrt(discrim);

                var 
                    plus_t = (dir_dot_delta + abs_discrim_root) / dir_squared_length,
                    minus_t = (dir_dot_delta - abs_discrim_root) / dir_squared_length;

                var
                    intersection_t = Math.min(plus_t, minus_t);

                var
                    intersection_point = sum(one.position, scale(normalized(dir), intersection_t));

                var
                    n_i = normalized(diff(intersection_point, one.position)),
                    n_j = normalized(diff(intersection_point, two.position));

                var
                    reflected_i = reflect(one.velocity, n_j),
                    reflected_j = reflect(two.velocity, n_i);

                one.velocity = reflected_i;
                two.velocity = reflected_j;
            }
        }

        function intersect_particles2(one, two)
        {
            var
                spoke = diff(two.position, one.position),
                unital_spoke = normalized(spoke),
                rad = perp(spoke);

            var
                diff_squared_radii = one.radius * one.radius - two.radius * two.radius;
                squared_spoke_length = dot(spoke, spoke);

            var
                s = 0.5 * ((diff_squared_radii / squared_spoke_length) + 1),
                t = ((one.radius * one.radius) / squared_spoke_length) - s * s;

            var
                l0 = length(spoke),
                l1 = one.radius - two.radius,
                l2 = one.radius + two.radius;

            if (l1 < l0 && l2 > l0)
            {
                // This is lame
                one.forces = sum(one.forces, scale(reflect(one.velocity, unital_spoke), 2.0));
                //two.forces = sum(two.forces, reflect(two.velocity, unital_spoke));
            }
        }

        function compute_forces(particles)
        {
            // For this simple system, aside from the initial impulses the only forces
            // are those arising from inelastic collisions
            for(var i = 0; i < particles.length; i++)
            {
                for(var j = 0; j < particles.length; j++)
                {
                    if (i == j) continue;

                    intersect_particles2(particles[i], particles[j]);
                    //intersect_particles(particles[i], particles[j]);
                }
            }
        }

        function warp(coord, bound)
        {
            if (coord < 0)
            {
                return bound;
            }
            else if (coord > bound)
            {
                return 0;
            }

            return coord;
        }

        function step(particles, dt)
        {
            // TODO: parameterize integrator
            //
            _.each(particles, function(particle)
            {
                // First apply the direct force
                particle.velocity[0] += (particle.forces[0]);// * dt);
                particle.velocity[1] += (particle.forces[1]);// * dt);

                particle.position[0] += particle.velocity[0] * dt;
                particle.position[1] += particle.velocity[1] * dt;

                // Turn our viewport into a torus!
                particle.position[0] = warp(particle.position[0], 600);
                particle.position[1] = warp(particle.position[1], 300);

                // Then the indirect
                //particle = force.potential(particle);
            });
        }

        function animate(particles, canvas, context, startTime) 
        {
            // TODO: use a fixed timestep
            //
            var time = (new Date()).getTime();
            var dt = time - startTime;

            // clear
            context.clearRect(0, 0, canvas.width, canvas.height);

            clear_forces(particles);
            compute_forces(particles);
            step(particles, dt);

            // draw it
            _.each(particles, function(particle) 
            {
                drawParticle(particle, context);
            });

            startTime = time;

            // request new frame
            requestAnimFrame(function() {
              animate(particles, canvas, context, startTime);
            });
        }

        var canvas = document.getElementById('render-window');
        var context = canvas.getContext('2d');

        // wait one second before starting animation
        setTimeout(function() 
        {
            var startTime = (new Date()).getTime();
            animate(particles, canvas, context, startTime);
        }, 1000);

    </script>
  </body>
</html>
